<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ERDDAP MCP LLM Demo</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", sans-serif;
      background-color: #ffffff;
      color: #1a1a1a;
      --primary: #003478;
      --primary-light: #0047a3;
      --primary-dark: #002550;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: var(--page-bg, #ffffff);
    }

    main {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }

    h1 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: clamp(1.8rem, 2vw, 2.2rem);
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--primary);
    }

    p.description {
      margin-top: 0;
      color: #666;
      font-size: 0.95rem;
      line-height: 1.6;
      max-width: 700px;
    }

    section.panel {
      background: #ffffff;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      padding: 24px;
      margin-bottom: 12px;
    }

    section.panel h2 {
      margin-top: 0;
      margin-bottom: 16px;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--primary);
    }

    section.panel h3 {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 1rem;
      font-weight: 600;
      color: var(--primary);
    }

    form#chat-form {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }

    label {
      font-weight: 500;
      font-size: 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 8px;
      color: #333;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      border-radius: 6px;
      border: 1px solid #d0d0d0;
      padding: 10px 12px;
      font-size: 0.95rem;
      background-color: #fafafa;
      color: #1a1a1a;
      transition: border-color 0.2s ease, background-color 0.2s ease;
      font-family: inherit;
    }

    input[type="text"]:hover,
    input[type="password"]:hover,
    textarea:hover,
    select:hover {
      border-color: #bbb;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--primary);
      background-color: #fff;
      box-shadow: 0 0 0 2px rgba(0, 52, 120, 0.1);
    }

    textarea {
      min-height: 100px;
      resize: vertical;
      font-family: inherit;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: flex-end;
      margin-top: 4px;
    }

    .button-row .status {
      margin-right: auto;
      order: -1;
    }

    button {
      border-radius: 6px;
      border: 1px solid var(--primary);
      padding: 10px 24px;
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s ease;
      background: var(--primary);
      color: #fff;
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }

    button:hover:not(:disabled) {
      background: var(--primary-light);
      border-color: var(--primary-light);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 52, 120, 0.2);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      background: var(--primary-dark);
      border-color: var(--primary-dark);
    }

    button.secondary {
      background: #fff;
      color: var(--primary);
      border-color: var(--primary);
    }

    button.secondary:hover:not(:disabled) {
      background: rgba(0, 52, 120, 0.05);
      border-color: var(--primary-light);
      color: var(--primary-light);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .status {
      font-size: 0.8rem;
      color: #999;
      min-height: 1.2em;
      font-weight: 500;
    }

    .chat-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .chat-composer {
      border-top: 1px solid #e0e0e0;
      padding-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .chat-composer textarea {
      min-height: 100px;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .transcript {
      max-height: min(60vh, 500px);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding-right: 8px;
    }

    .transcript::-webkit-scrollbar {
      width: 6px;
    }

    .transcript::-webkit-scrollbar-track {
      background: transparent;
    }

    .transcript::-webkit-scrollbar-thumb {
      background: #d0d0d0;
      border-radius: 3px;
    }

    .transcript::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    .message {
      border-radius: 8px;
      padding: 12px 16px;
      background: #f5f5f5;
      border: 1px solid #e0e0e0;
      position: relative;
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.5;
    }

    .message.user {
      margin-left: auto;
      background: var(--primary);
      color: #fff;
      border: 1px solid var(--primary-dark);
      max-width: 85%;
    }

    .message.assistant {
      margin-right: auto;
      max-width: 85%;
      background: #f9f9f9;
      border: 1px solid rgba(0, 52, 120, 0.1);
    }

    .message.tool {
      margin-right: auto;
      max-width: 85%;
      background: rgba(0, 52, 120, 0.05);
      border: 1px solid rgba(0, 52, 120, 0.15);
      border-left: 3px solid var(--primary);
    }

    .message.debug {
      font-size: 0.8rem;
      background: #f0f0f0;
      color: #555;
    }

    .message h4 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      color: inherit;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .loading-dots {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 0;
    }

    .loading-dots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: var(--primary);
      opacity: 0.4;
      animation: loading-pulse 1.4s infinite ease-in-out;
    }

    .loading-dots span:nth-child(1) {
      animation-delay: 0s;
    }

    .loading-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .loading-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes loading-pulse {
      0%, 60%, 100% {
        opacity: 0.4;
        transform: scale(0.8);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
    }

    pre {
      background: #f0f0f0;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.8rem;
      line-height: 1.4;
      margin: 8px 0 0 0;
      border: 1px solid #e0e0e0;
    }

    code {
      font-family: "SF Mono", "Monaco", "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace;
      font-size: 0.8rem;
    }


    @media (max-width: 640px) {
      main {
        padding: 24px 16px;
      }

      h1 {
        font-size: 1.5rem;
      }

      .message.user,
      .message.assistant,
      .message.tool {
        max-width: 100%;
      }

      .button-row {
        flex-direction: column;
        gap: 8px;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <main>
    <h1>ERDDAP MCP LLM Demo</h1>
    <p class="description">
      Chat with an OpenAI model that can call the ERDDAP MCP server to explore datasets.
    </p>

    <section class="panel">
      <h2 style="margin-top:0;margin-bottom:16px;font-size:1.1rem;font-weight:600;color:var(--primary);">Configuration</h2>
      <div class="grid" style="margin-bottom:16px;">
        <label>
          OpenAI API Key
          <input id="api-key" type="text" placeholder="sk-..." autocomplete="off" required>
        </label>
      </div>

      <div class="grid two">
        <label>
          ERDDAP URL
          <input id="erddap-url" type="text" value="https://erddap.maracoos.org/erddap" autocomplete="off">
        </label>

        <label>
          MCP Server URL
          <input id="mcp-url" type="text" value="https://mapapps.oceansmap.com/erddap-mcp" autocomplete="off">
        </label>
      </div>
    </section>

    <section class="panel">
      <form id="chat-form">
        <div class="chat-panel">
          <div class="chat-header">
            <h2 style="margin:0;font-size:1.1rem;font-weight:600;color:var(--primary);">Conversation</h2>
            <button id="clear-button" type="button" class="secondary">Clear Conversation</button>
          </div>

          <div class="chat-container">
            <div id="transcript" class="transcript" aria-live="polite"></div>

            <div class="chat-composer">
              <label class="sr-only" for="user-input">Message</label>
              <textarea id="user-input" placeholder="Ask about datasets, variables, or time ranges..." required></textarea>
              <div class="button-row">
                <span class="status" id="status"></span>
                <button id="send-button" type="submit">Send</button>
              </div>
            </div>
          </div>
        </div>
      </form>
    </section>

  </main>

  <script>
    const defaultSystemPrompt = `You are a helpful assistant that explores ERDDAP datasets for the user. Prefer the configured ERDDAP URL unless the user asks for another. Summarize findings clearly, cite dataset IDs, and link to ERDDAP resources when appropriate.`;

    const transcriptEl = document.getElementById("transcript");
    const formEl = document.getElementById("chat-form");
    const erddapInput = document.getElementById("erddap-url");
    const mcpInput = document.getElementById("mcp-url");
    const userInput = document.getElementById("user-input");
    const sendButton = document.getElementById("send-button");
    const clearButton = document.getElementById("clear-button");
    const statusEl = document.getElementById("status");

    const state = {
      messages: []
    };

    function updateSendButtonState() {
      const apiKey = document.getElementById("api-key").value.trim();
      const userText = userInput.value.trim();
      sendButton.disabled = !apiKey || !userText;
      // Clear any error messages when user starts typing
      if (userText || apiKey) {
        statusEl.textContent = "";
      }
    }

    function escapeHtml(value) {
      return value
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function renderMessage(role, htmlContent) {
      const wrapper = document.createElement("div");
      wrapper.className = `message ${role}`;
      wrapper.innerHTML = htmlContent;
      transcriptEl.appendChild(wrapper);
      transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }

    function renderToolEvent(title, content) {
      const wrapper = document.createElement("div");
      wrapper.className = "message tool";
      wrapper.innerHTML = `<h4>${title}</h4>${content}`;
      transcriptEl.appendChild(wrapper);
      transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }

    function createStreamingMessage(role) {
      const wrapper = document.createElement("div");
      wrapper.className = `message ${role}`;
      const contentEl = document.createElement("div");
      
      // Show loading animation initially
      contentEl.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>';
      wrapper.appendChild(contentEl);
      transcriptEl.appendChild(wrapper);
      transcriptEl.scrollTop = transcriptEl.scrollHeight;

      let textQueue = [];
      let animationId = null;
      let currentText = "";
      let isLoading = true;

      const removeLoadingDots = () => {
        if (isLoading) {
          contentEl.innerHTML = '';
          isLoading = false;
        }
      };

      const animate = () => {
        if (textQueue.length === 0) {
          animationId = null;
          return;
        }

        const nextChunk = textQueue.shift();
        currentText += nextChunk;
        contentEl.textContent = currentText;
        transcriptEl.scrollTop = transcriptEl.scrollHeight;
        animationId = requestAnimationFrame(animate);
      };

      return {
        appendText(text) {
          if (!text) return;
          removeLoadingDots();
          const chars = text.split('');
          textQueue.push(...chars);
          if (animationId === null) {
            animate();
          }
        },
        setHTML(html) {
          removeLoadingDots();
          if (animationId !== null) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          wrapper.innerHTML = html;
          transcriptEl.scrollTop = transcriptEl.scrollHeight;
        },
        finalize() {
          removeLoadingDots();
          if (animationId !== null) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          // Flush any remaining text
          if (textQueue.length > 0) {
            currentText += textQueue.join('');
            contentEl.textContent = currentText;
            textQueue = [];
          }
        },
        remove() {
          if (animationId !== null) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          wrapper.remove();
        }
      };
    }

    function formatContentItems(content = []) {
      return content.map((item) => {
        if (!item || typeof item !== "object") {
          return `<pre>${escapeHtml(String(item))}</pre>`;
        }

        switch (item.type) {
          case "output_text":
          case "input_text":
            return `<div>${escapeHtml(item.text ?? "")}</div>`;
          case "tool_call":
          case "tool_use": {
            const name = escapeHtml(item.name ?? item.tool_name ?? "tool");
            const args = escapeHtml(JSON.stringify(item.input ?? item.arguments ?? {}, null, 2));
            return `<div><strong>Tool Request:</strong> ${name}<pre>${args}</pre></div>`;
          }
          case "tool_result":
          case "tool_response": {
            const label = escapeHtml(item.tool_call_id ?? item.id ?? "tool");
            const payload = item.result ?? item.output ?? item.content ?? item.text ?? item.data ?? "";
            const formatted = typeof payload === "string" ? payload : JSON.stringify(payload, null, 2);
            return `<div><strong>Tool Result (${label}):</strong><pre>${escapeHtml(formatted)}</pre></div>`;
          }
          case "json_schema":
            return `<pre>${escapeHtml(JSON.stringify(item, null, 2))}</pre>`;
          default:
            return `<pre>${escapeHtml(JSON.stringify(item, null, 2))}</pre>`;
        }
      }).join("");
    }

    function buildSystemMessage(erddapUrl) {
      const currentTime = new Date().toISOString();
      const suffix = `\nCurrent datetime: ${currentTime}\nDefault ERDDAP endpoint: ${erddapUrl}. Use MCP tools when data is required. If the user provides a different ERDDAP, follow their instruction.`;
      return {
        role: "system",
        content: [
          {
            type: "input_text",
            text: `${defaultSystemPrompt}${suffix}`
          }
        ]
      };
    }

    function buildRequestBody() {
      const apiKey = document.getElementById("api-key").value.trim();
      
      if (!apiKey) {
        throw new Error("OpenAI API key is required. Please enter your API key in the 'OpenAI API Key' field.");
      }

      const erddapUrl = erddapInput.value.trim() || "https://erddap.maracoos.org/erddap";
      const mcpUrl = mcpInput.value.trim() || "https://mapapps.oceansmap.com/erddap-mcp";
      const model = "gpt-4.1-mini";

      const request = {
        model,
        input: [buildSystemMessage(erddapUrl), ...state.messages],
        tools: [
          {
            type: "mcp",
            server_label: "erddap-mcp",
            server_url: mcpUrl,
            require_approval: "never"
          }
        ],
        metadata: {
          erddap_url: erddapUrl
        }
      };

      return { request, apiKey };
    }

    function setStatus(message, isError = false) {
      statusEl.textContent = message;
      statusEl.style.color = isError ? "#d63031" : "#525e75";
    }

    function handleResponseData(data) {
      const toolResults = Array.isArray(data?.tool_results) ? data.tool_results : [];
      const outputs =
        Array.isArray(data?.output) ? data.output :
        Array.isArray(data?.content) ? data.content :
        toolResults;

      let assistantMessages = [];

      outputs.forEach((entry) => {
        if (!entry) {
          return;
        }

        if (entry.type === "message" && entry.message) {
          assistantMessages.push(entry.message);
          const formatted = formatContentItems(entry.message.content);
          renderMessage("assistant", formatted);
        } else if (entry.type === "tool_result" || entry.type === "tool_use" || entry.type === "tool_call") {
          const toolContent = entry.content ?? entry.output ?? entry.result ?? entry;
          const formatted = formatContentItems(Array.isArray(toolContent) ? toolContent : [toolContent]);
          const title = entry.type.replace(/_/g, " ").toUpperCase();
          renderToolEvent(title, formatted);
        } else if (entry.role && entry.content) {
          assistantMessages.push({ role: entry.role, content: entry.content });
          const formatted = formatContentItems(entry.content);
          renderMessage(entry.role === "user" ? "user" : "assistant", formatted);
        }
      });

      if (!assistantMessages.length && toolResults.length) {
        toolResults.forEach((result) => {
          const formatted = formatContentItems(result.output ?? result.content ?? []);
          renderToolEvent("TOOL RESULT", formatted);
        });
      }

      if (!assistantMessages.length && Array.isArray(data?.messages)) {
        data.messages.forEach((msg) => {
          if (!msg || !msg.role || !Array.isArray(msg.content)) {
            return;
          }

          const renderedRole = msg.role === "user" ? "user" : "assistant";
          assistantMessages.push({ role: msg.role, content: msg.content });
          renderMessage(renderedRole, formatContentItems(msg.content));
        });
      }

      if (!assistantMessages.length && typeof data?.output_text === "string") {
        const assistantMessage = {
          role: "assistant",
          content: [{ type: "output_text", text: data.output_text }]
        };
        assistantMessages.push(assistantMessage);
        renderMessage("assistant", formatContentItems(assistantMessage.content));
      }

      assistantMessages.forEach((msg) => {
        state.messages.push({ role: msg.role, content: msg.content });
      });
    }

    async function sendMessage() {
      const userText = userInput.value.trim();
      if (!userText) {
        return;
      }

      // Check if API key is provided
      const apiKey = document.getElementById("api-key").value.trim();
      if (!apiKey) {
        setStatus("Please enter your OpenAI API key before sending a message.", true);
        return;
      }

      const userMessage = {
        role: "user",
        content: [{ type: "input_text", text: userText }]
      };

      state.messages.push(userMessage);
      renderMessage("user", formatContentItems(userMessage.content));
      userInput.value = "";

      const { request } = buildRequestBody();

      sendButton.disabled = true;

      let streamingMessage = null;

      try {
        const response = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${apiKey}`,
            "OpenAI-Beta": "tools=v1"
          },
          body: JSON.stringify({ ...request, temperature: 0.2, stream: true })
        });

        if (!response.ok) {
          const errorPayload = await response.json().catch(() => ({}));
          const message = errorPayload?.error?.message || response.statusText || "Unknown error";
          throw new Error(message);
        }

        const contentType = response.headers.get("content-type");
        const isStreaming = contentType?.includes("text/event-stream") || contentType?.includes("application/x-ndjson");

        if (!isStreaming) {
          // Handle non-streaming response
          const data = await response.json();
          handleResponseData(data);
          return;
        }

        // Handle streaming response
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let assistantMessages = [];
        let currentText = "";

        streamingMessage = createStreamingMessage("assistant");

        while (true) {
          const { done, value } = await reader.read();
          
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || "";

          for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed || trimmed.startsWith('data: [DONE]')) continue;

            // Handle stream format
            const dataLine = trimmed.startsWith('data: ') ? trimmed.substring(6) : trimmed;

            try {
              const data = JSON.parse(dataLine);

              // Handle different streaming event types
              if (data.type === "response.output_text.delta" && data.delta) {
                currentText += data.delta;
                streamingMessage.appendText(data.delta);
              } else if (data.type === "response.output_text.done") {
                streamingMessage.finalize();
                const assistantMessage = {
                  role: "assistant",
                  content: [{ type: "output_text", text: data.text || currentText }]
                };
                assistantMessages.push(assistantMessage);
                state.messages.push(assistantMessage);
              } else if (data.type === "response.done") {
                // Response completed
              } else if (data.choices && data.choices[0]?.delta?.content) {
                // OpenAI chat completion streaming format
                const content = data.choices[0].delta.content;
                currentText += content;
                streamingMessage.appendText(content);
              } else if (data.output || data.content) {
                // Full response in streaming format
                if (streamingMessage) {
                  streamingMessage.remove();
                  streamingMessage = null;
                }
                handleResponseData(data);
              }
            } catch (e) {
              console.warn("Failed to parse streaming line:", dataLine, e);
            }
          }
        }

        // If we accumulated text but no done event, finalize it
        if (streamingMessage && currentText && assistantMessages.length === 0) {
          streamingMessage.finalize();
          const assistantMessage = {
            role: "assistant",
            content: [{ type: "output_text", text: currentText }]
          };
          state.messages.push(assistantMessage);
        } else if (streamingMessage && assistantMessages.length === 0) {
          streamingMessage.remove();
          streamingMessage = null;
        }

        if (assistantMessages.length === 0 && currentText === "") {
          setStatus("No response received", true);
        }

      } catch (error) {
        if (streamingMessage) {
          streamingMessage.remove();
        }
        renderMessage("assistant", `<div style="color:#d63031;">Error: ${escapeHtml(error.message)}</div>`);
        setStatus(error.message, true);
      } finally {
        sendButton.disabled = false;
      }
    }

    formEl.addEventListener("submit", (event) => {
      event.preventDefault();
      sendMessage();
    });

    clearButton.addEventListener("click", () => {
      state.messages = [];
      transcriptEl.innerHTML = "";
      statusEl.textContent = "";
    });

    // Load saved API key from localStorage
    const savedApiKey = localStorage.getItem("openai_api_key");
    if (savedApiKey) {
      document.getElementById("api-key").value = savedApiKey;
    }

    // Add event listeners to update send button state
    const apiKeyInput = document.getElementById("api-key");
    apiKeyInput.addEventListener("input", () => {
      updateSendButtonState();
      // Save API key to localStorage
      const apiKey = apiKeyInput.value.trim();
      if (apiKey) {
        localStorage.setItem("openai_api_key", apiKey);
      } else {
        localStorage.removeItem("openai_api_key");
      }
    });
    userInput.addEventListener("input", updateSendButtonState);

    // Add Enter key handler for chat input
    userInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        if (!sendButton.disabled) {
          sendMessage();
        }
      }
    });

    // Initialize button state
    updateSendButtonState();
  </script>
</body>
</html>
